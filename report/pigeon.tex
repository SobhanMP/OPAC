\documentclass{article}
\usepackage{optidef}
\usepackage[graphicx]{realboxes}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{amssymb}
\usepackage{showlabels}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\usepackage{booktabs}
\usepackage{subfig}
\usepackage[font=sf]{caption}
\usepackage[font=sf]{floatrow}
\usepackage{siunitx}
\usepackage[style=alphabetic]{biblatex}

\usepackage{accents}
\newcommand{\ubar}[1]{\underaccent{\bar}{#1}}

\addbibresource{pigeon.bib}
\author{Sobhan Mohammadpour}
\title{OPAC: Optimal Packet over Avian Carriers}
\begin{document}
	\maketitle
	\section{Motivation}
	
	Imagine on hot summer day, you need to send a few terabytes of data to a friend that lives down the block, you somehow manage to find a service that allows you to upload that much data and start uploading. However, you realize that the upload is going to take too much time and so decided to just give an external HDD to your friend.
	
	
	Inspired by the IP over Avian protocol  and a story from South Africa \autocite{abellAfricaPigeonTransfers} where the owners of a telecome company sent their data strapped to a pigeon which was much faster than uploading data. 
	
	These days 1TB micro-SD cards are fairly cheap so it's not hard to imagine that someone actually does this. But the real use-case is not necessarily with pigeons but with drones and unmanned airplanes. While normal conditions may not require such a drastic and cumbersome way of communication, in the event of disaster (man-made or otherwise), setting up a mesh network is generally preferred over total lack of networking. In such a mesh network, we want to improve the transfer rate by augmenting the network with a high capacity, high cost and very limited series of agents that can transfer the data by jumping over the nodes in the mesh network.
	
	We note that the main difference between a ``normal" communication network and a mesh one is the presence of cycles.
	
	\section{Problem Definition}
	The goal is to transfer a number commodities enumerated by the elements of $K$, all while selecting the routes pigeons have to to minimize the cost.
	
	
	Let
	\begin{enumerate}
			\item $K$ be the set of tasks and,
		\item $P$ be the set of pigeons,
		\item $V$ be the set of nodes in the mesh network,
		\item $E \subset V \times V$ be the arc connecting those nodes,
		\item $N^p \subset V$ be the set of node bird $p$ can travel between and,
		\item $A^p \subset N\times N$ be the set of arcs bird $p$ have to travel on.
	\end{enumerate}


	
	\begin{mini!}[3]
		{}
		{
			\sum_{p\in P} v^p a^p   +
			\sum_{k\in K}\left(
			\sum_{e \in E} c_e x^k_e + \sum_{p \in P, i\in V} gu^{pk}_{i} + hd^{pk}_{i}
			\right)
		}
		{}
		{}
		%
		\addConstraint
			{\sum_{k} x^k_e \leq}
			{m_e,}
			{ \quad e \in E \label{eqs:land_const} }
		\addConstraint{l^p_e \leq}{a^p}{ \quad p \in P, e \in A^p \label{eqs:air_active}}
		\addConstraint{\sum y^{pk}_e \leq}{ql^p_e,}{ \quad p \in P, e \in A^p \label{eqs:air_cap}}
		\addConstraint{\sum_{e \in A^p}l^p_e \ell_e \leq}{L,}{ \quad p \in P \label{eqs:max_length} }
		\addConstraint{\sum_{(i, j) \in E^p} l^p_{ij}=}{\sum_{(j, i) \in E^p} l^p_{ji},}{ \quad p \in P, i \in N^p \label{eqs:air_cycle} }
		\addConstraint{U^p_i - U^p_j + 1\leq}{|N^p|(s^p_i + s^p_j + 1 - l^p_{ij}),}{ \quad p \in P, (i,j)\in E^p  \label{eqs:MTZ} }
		\addConstraint{\sum_{i \in N^p}s^p_i=}{ a^p}{ \quad p \in P \label{eqs:smax}}
		\addConstraint{\delta^k_i + \sum_{p \in P}u^{pk}_i - d^{pk}_i=}{\sum_{(i,j) \in E}x_{ij}^k - \sum_{(j, i) \in E}x_{ji}^k}{\quad i \in V \label{eqs:flow_land}}
		\addConstraint{u^{pk}_i + \sum_{(j, i) \in A^p} y^{pk}_{ji} =}{d^{pk}_i + \sum_{(i, j) \in A^p} y^{pk}_{ij}}{\quad p\in P, i \in N^p \label{eqs:flow_air}}
		%
	\end{mini!}
	where
	\begin{enumerate}
		\item $a^p \in \{0, 1\}$ indicates whether the pigeon $p$ is active,
		\item $x^k_e \in \mathbb{R}^+$ is the flow of commodity $k$ on arc $e$,
		\item $u^{pk}_i \in \mathbb{R}^+$ and $d^{pk}_i\in \mathbb{R}^+$ are, respectively, the upload amount and download amount of the data from task $k$ to and from the pigeon $p$,
		\item $l^p_e \in \{0, 1\}$ indicates whether arc $e \in A^p$ is active for pigeon $p \in P$,
		\item $s^p_i \in \{0, 1\}$ indicates if the loop of the pigeon $p$ started at node $i$, and
		\item $0 \leq U^p_i \leq |N^p|$ is an MTZ(cite) like potential for each node $i$ and pigeon $p$,
	\end{enumerate}
	and
	\begin{enumerate}
	\item $v$ is the cost of using a pigeon,
	\item $c_e$ is the cost of one unit of flow on arc $e$,
	\item $g$ is the cost of uploading one unit of data to a pigeon,
	\item $h$ is the cost of downloading one unit of data from a pigeon
	\item $m_e$ is the capacity of the edge e,  
	
	\item $L$ be the maximum distance pigeons can travel,
	\item $\ell_e$ is the length of edge $e$,
	\item $q$ is the maximum capacity of pigeons, and
	\item $\delta^k_{i}$ be the flow constraint's rhs for the node $i$ and the task $k$ i.e. for a transfer $v$, it results $-v$ at the origin of the transfer, $v$ at the destination and zero other wise such.
	\end{enumerate}
	The  
	\begin{enumerate}
		\item constraint (\ref{eqs:land_const}) defines the capacity of the mesh network, 
		\item constraint (\ref{eqs:land_const}) force the capacity of inactive pigeons to be zero,
		\item constraint (\ref{eqs:air_cap}) enforces the pigeon capacity of pigeons,
		\item constraint (\ref{eqs:max_length}) forces the travel distance of each pigeon to be less than L,
		\item constraint (\ref{eqs:air_cycle}) forces the paths of pigeons to consist of cycles,
		\item constraint (\ref{eqs:MTZ}) is an MTZ(cite) like constraint that forces only one simple cycle to exist, The main difference with MTZ is that the constraints are defined for all nodes but the node whose $s$ is $1$ will not have any active constraints as the right hand side will be at least $|N^p|$ thus practically disabling the constraints that contain that node,
		\item constraint (\ref{eqs:smax}) forces one of the $s^p_i$ to be $1$ when the pigeon is active,
		\item constraint (\ref{eqs:flow_land}) is the flow conservation constraint on the mesh, and 
		\item constraint (\ref{eqs:flow_air}) is the flow conservation constraint for the pigeons.
	\end{enumerate}


	We while we assume that the pigeons are the same, it's fairly easy to extend all pigeon properties by an index $p$ to make them unique. Furthermore, we assume that for $a=0$ i.e. no pigeons are active, the problem is feasible. 
	\section{Benders' ecomposition}
	
	In the problem
	\begin{mini!}
		{}{c\cdot x + d \cdot y}{}{}
		\addConstraint{Ax + By}{ = b}
		\addConstraint{x}{\geq 0,}
	\end{mini!}
	where $x$ is a real valued vector in $\mathbb{R}^n$ and $y$ is a integer vector in $\mathbb{Z}^m$, we can re-write the problem as bi-level problem such that
	\begin{mini!}
		{}{\theta + d \cdot y}{}{}
		\addConstraint{\theta \in \argmin_x\{c\cdot x | Ax = b - By, x\geq 0\}.\label{benders:2:sp}}
	\end{mini!}
	or alternatively since the outer problem is a minimization, 
	\begin{mini!}
		{}{\theta + d \cdot y}{}{}
		\addConstraint{\theta \geq}{ \min_x\{c\cdot x | Ax = b - By, x\geq 0\}}
		\addConstraint{\emptyset \neq}{\{x \in \mathbb{R}^n| Ax = b - By, x\geq 0\}.}
	\end{mini!}
	We can dualize the subproblem to get
	\begin{mini!}
		{}{\theta + d \cdot y}{}{}
		\addConstraint{\theta \geq}{ \max_ \pi\{(b - By)\cdot  \pi | A^\top  \pi \leq c, \}.\label{benders:3:sp}}
	\end{mini!}
	We now longer need the feasibility constraint because the sub-problem is never unbounded(assuming the original problem is bounded) as such the dual problem is never infeasible but is unbounded (infinity) at infeasible points. This forces the problem to be feasible
	
	(Cite benders) showed that this problem can be modeled as a finite number of cuts such that
	\begin{mini!}
		{}{\theta + d \cdot y}{}{}
		\addConstraint{\theta \geq}{(b - By)^\top  \pi,\label{benders:2:sp}}{\quad  \pi \in \mathcal{P}}
		\addConstraint{0 \geq }{(b - By)^\top  \pi}{\quad  \pi \in \mathcal{R},}
	\end{mini!}
 	where $\mathcal{P}$ and $\mathcal{R}$ are the set of extreme points and extreme rays of (\ref{benders:3:sp}). We note that if $\bar{y}$ is the point where the cut was generated and $\theta^0$ is the objective of the dual (or the dual ray if it is unfeasible), we can write $(b - By)^\top  \pi$ as $\theta^0 - (By - B\bar{y})^\top  \pi$ since $\theta^0 = (b - B\bar{y})^\top \pi$. Since the number of cuts is finite, we can dynamically add those to the problem as need i.e. they become invalidated. The cuts are on the extreme rays are called feasibility cuts and are only needed when the sub-problem is not feasible.The problem that has the benders cut is called the master problem and the problem that is used to generate the cuts is called the sub-problem. 
 	
	While benders original method would add these cuts at integer points, (cite inexact cuts) showed that the cuts can be added even in fractional points. Furthermore, (cite Mangati-Want) showed that if the cuts are generated with a core point and an additional constraint it will be non-dominated. (cite papadakos) showed that the additional constraint is not needed and we can take a moving average of $y^t$ as our core point. The choice of the moving average coefficient greatly changes the performance of the method. We use $l=0.001$ as our core-point.
	
	Our problem is a good candidate for benders decomposition as the constraints (\ref{eqs:flow_land}) and (\ref{eqs:flow_air}) only contain real variables and the constraint (\ref{eqs:air_cap}) is the only linking constraint between the integer and real variables. We note that we keep the $U$ in the master problem. This does not cause any problem on the theoretical level and helps reduce the number of infeasibility cuts. 
    When taking out $x$ and $y$ out of the master problem, we only need to add cuts for the constraints that have integer variables in them (otherwise they will just be zero). In the constraint(\ref{eqs:air_cap}) constraint matrix $B$ is the identity matrix times $q$. The cuts will be in the form of 
	\begin{equation}
		\theta \geq \theta^0  - q\sum_{p \in P, e \in A^p} (l^p_e - \bar{l}^p_e) \pi^p_e
	\end{equation}
	and
	\begin{equation}
		0 \geq \theta^0 - q\sum_{p \in P, e \in A^p} (l^p_e - \bar{l}^p_e)  \pi^p_e,
	\end{equation}
	where $ \pi^p_e$ is the dual variable associated with the constrain (\ref{eqs:air_cap}).
	
	 
	 The master is 
		\begin{mini!}
		{}
		{
			\sum_{p\in P} v^p a^p + \theta
		}
		{}
		{}
		%
		\addConstraint{l^p_e \leq}{a^p}{ \quad p \in P, e \in A^p \label{bm:eqs:air_active}}
		\addConstraint{\sum_{e \in A^p}l^p_e \ell_e \leq}{L,}{ \quad p \in P \label{bm:eqs:max_length} }
		\addConstraint{\sum_{(i, j) \in E^p} l^p_{ij}=}{\sum_{(j, i) \in E^p} l^p_{ji},}{ \quad p \in P, i \in N^p \label{bm:eqs:air_cycle} }
		\addConstraint{U^p_i - U^p_j \leq}{|N^p|(s^p_i + s^p_j + 1 - l^p_{ij}) - 1,}{ \quad p \in P, (i,j)\in E^p  \label{bm:eqs:MTZ} }
		\addConstraint{\sum_{i \in N^p}s^p_i=}{ a^p}{ \quad p \in P \label{bm:eqs:smax}}
		\addConstraint{\theta \geq}{\theta^0 - q\sum_{p \in P, e \in A^p} (l^p_e - \bar{l}^p_e) \pi^p_,}{\quad  \pi,\bar{l},\theta^0 \in \mathcal{P}}
		\addConstraint{0 \geq }{\theta^0 - q\sum_{p \in P, e \in A^p} (l^p_e - \bar{l}^p_e)  \pi^p_e,}{\quad  \pi,\bar{l},\theta^0 \in \mathcal{R},}
	\end{mini!}
where $\mathcal{P}$ and $\mathcal{R}$ are the extreme cones and rays with their corresponding objective, 
	and the Benders sub-problem is
		\begin{mini!}[3]
		{}
		{
			\sum_{k\in K}
			\sum_{e \in E} c_e x^k_e + \sum_{p \in P, i\in V} gu^{pk}_{i} + hd^{pk}_{i}
		}
		{}
		{SP(\bar{l})=}
		\addConstraint
		{\sum_{k} x^k_e \leq}
		{m_e,}
		{ \quad e \in E \label{sp:eqs:land_const} }
		\addConstraint{-\sum y^{pk}_e \geq}{-q\bar{l}^p_e,}{ \quad p \in P, e \in A^p \label{sp:eqs:air_cap}}
		\addConstraint{\delta^k_i + \sum_{p \in P}u^{pk}_i - d^{pk}_i=}{\sum_{(i,j) \in E}x_{ij}^k - \sum_{(j, i) \in E}x_{ji}^k}{\quad i \in V \label{sp:eqs:flow_land}}
		\addConstraint{u^{pk}_i + \sum_{(j, i) \in A^p} y^{pk}_{ji}}{ =  d^{pk}_i  + \sum_{(i, j) \in A^p} y^{pk}_{ij}}{\quad p\in P, i \in N^p \label{sp:eqs:flow_air}.}
		%
	\end{mini!}
	
	The subproblem is called the multi-commodity  min cost flow problem.
	
	
	\section{Dantzig-Wolfe decomposition and Column generation}
	
	
	
	
	For any linear problem in the form


	\begin{mini!}
		{}{c\cdot x}{}{}
		\addConstraint{Ax}{\leq b}
		\addConstraint{Bx}{\leq c.}
	\end{mini!}
	
	We can rewrite it as 
	
	\begin{mini!}
		{}{c\cdot x}{}{}
		\addConstraint{x}{ = \sum_{i=1,\ldots,n}\lambda^i y^i + \sum_{i=1,\ldots, m} \mu^i r^i}
		\addConstraint{\sum_{i=1,\ldots,n}\lambda^i}{ = 1}
		\addConstraint{\lambda, \mu}{ \geq 0}
		\addConstraint{Bx}{\leq c,}
	\end{mini!}
	where $y_1,\ldots,y_n$ are the extreme points of 
	\begin{equation}
		P = \{x | Ax \leq b\}
	\end{equation}
	and $\mu_1,\ldots,\mu_m$ are extreme rays of $P$. This is called the Dantzig-Wolfe decomposition (cite?) and has been shown (by whom?) that the new problem is equivalent to the old one. The interest of this process is when a small subset of extreme points are active or convexifying the constraint $Ax \leq b$ leads to a special problem that breaks down into small problems.
	
	
	
	Column generation is the process of dynamically generating variables as needed. Let an LP like 
	\begin{mini!}
		{}{\sum_{i=1,\ldots, n}c_ix_i}{}{}
		\addConstraint{\sum_{i=1,\ldots, n} a^j_ix_i}{\leq b^j}{\quad j \in 1,\ldots,m,}
	\end{mini!}
 	assume that the problem has solution if we set $x_i$ $i=k,\ldots,n$ to zero. We start with the reduced problem with the variables $k$ to $n$ set to zero, solve the problem and add a new variable that can improve the objective. We can find variables that improve the reduced cost by looking at their reduced cost, we add a variables that has a negative reduced cost (what about zero?). It is possible to either enumerate all $x$ (if it is finite) or if the columns $a_i$ have special structure, we can reformulate the problem as an optimization problem over that special structure.
 	
 	
 	We fist decompose the multi-comodity flow problem with Dantzig-Wolfe into the arc-cycle formulations. Let the multi-comodity flow problem be 
 	\begin{mini!}{}{\sum_{k\in K, e \in E}c_e x^k_e}{}{}
		\addConstraint{Nx^k =}{b^k}{\quad k \in K}
		\addConstraint{\sum_{k \in K}x^k_e \leq}{u_e}{\quad e \in E,}
 	\end{mini!}
 	where $Nx=b^k$ is the flow conservation constraint for $k$th commodity, $x^k_e \leq u_e$ is the arc capacity constraint and $c \geq 0$. The extreme points of $Nx=b^k$ are the paths from the source the destination of the commodity (with the flow equal to the demand), the extreme rays are cycles. We know this is true because any valid flow matrix can be broken into simple paths and cycles (elaborate?). Thus we can reformulate the problem in term of paths and cycles. We also note that we considers paths with unite flow instead of paths with demand flow to simplify the formulation. Let $v^k$ be the demand of the $k$th commodity. However, the set of cycles is very large and has non negative cost as $c \geq 0$ thus we don't need to consider them. Let $P^k$ be the set of possible paths for the commodity $k$, for path $p$, let $f(p)$ be the flow, $c(p)$ the cost and $\delta_e(p)$ an indicator of the presence of the arc $e$ in the path $p$. We can rewrite the problem in term of paths (or extreme points) as
 	\begin{mini!}{}{\sum_{k\in K, p \in P^k} c(p) f(p),}{}{}
 		\addConstraint{\sum_{\quad k \in K, p \in P(k)} \delta_e(p)f(p) \leq}{u_e,}{\quad e \in E \label{path:cap}}
 		\addConstraint{\sum_{p \in P^k}f(p) =}{d^k,}{\quad k \in K. \label{path:cost}}
 		\addConstraint{f(p) \geq}{0,}{\quad k \in K, p \in P^k}
 	\end{mini!}
	Due to large number of paths and many extremely useless paths, we use column generation to generate a subset of all the paths. Let $w_e$ be the dual variable of constraint (\ref{path:cap}) and $\sigma$ be the dual of (\ref{path:cost}), we can see that in this form the dual $w_{ij}$ is negativewhile $\sigma_k$ but will stay positive as it will be the least expensive used path ($\max \sum\sigma$ s.t. $\sigma^k \leq c(p)$). The reduced cost of a path $p \in P^k$ will be (the coef behind $A$ is positive because we usually have to negate it to get a standard form and then negative it again)
	\begin{equation}
		c(p) + A^\top w - B^\top \sigma,
	\end{equation} 
	where $A^\top w$ is $\sum_{e \in p} w_e$ and $B^\top\sigma$ is $\sigma^k$. Thus the reduced of a path cost is
	\begin{equation}
		\sum_{e \in E} \delta_e(p) (c_e + w_e) - \sigma^k.
	\end{equation}
	For any commodity $k$, this amounts to finding a shortest path with adjusted costs since $\sigma_k$ is constant. Since $w$ is positive, the cost will stay positive and we can use Djikstra (cite)'s algorithm to find the shortest path. At each iteration we'll a shortest path to the set of basis. While in theory we only need to add one path who has a negative reduced cost, this helps accelerate things.
	
	While the usual approach is to use the revised simplex method and to discard the generated columns when they go out of the basis, we use a solver and keep those in case they become useful later on. 
	
	To initialize the problem let $M$ be a number strictly greater than the objective of the function, we add an auxiliary variable for each commodity such that the cost of this commodity is $M/d^k$ and the coef in the constraint (\ref{16c}) is (each variable appears once in the corresponding constraint). This allows to not start from a set of feasible columns. Furthermore, the initial set of column is generated via the Ford-Fulkerson(cite). 
	
	\section{Computational Study}
	
	We generate a series of instances where to mesh network is an $n$ by $n$ grid and the pigeons can move in another grid where to the nodes of this other grid is the nodes $s(i, j) + 1$ of the original network for a number $s$. So for instance the instance $(n, s)=(5, 2)$ will have a five by five mesh and the pigeons can visit the node $(1, 3, 5) \times (1, 3, 5)$.  each node has distance of 10 meter.
	
	\begin{figure}[h]
		\centering
		\subfloat[\centering mesh network]{{\includegraphics[width=5cm]{../images/01-lg.pdf} }}%
		\qquad
		\subfloat[\centering pigeon paths]{{\includegraphics[width=5cm]{../images/02-ag.pdf} }}%
		\caption{network for $(n, s) = (21, 5)$, note that the nodes with same relative position as the top right node are connected so for instance the middle node of both graph are connected.}
	\end{figure}
	
	For each of these instances we draw the arc cost from a uniform distirbution on the integer between 100 and 200. The paths are sampled using random walks. At each node, we consider all transition that have the potential to reach the destination w/o passing over already passed nodes. Out of all the possible transitions, we sample transitions with a probability proportional to the distance of that node to the destination. On this network the origin destination uniformly uniformly. The demand is sampled from a Poisson with $\lambda=10$ truncated between 1 and infinity. We then add the the demand to the capacity of all arcs that the path pass through. We repeat this process 5 times for each pair of node. At the end we multiply the capacity with an exponential truncated between $1$ et $1.05$.
	
	
	While it may not have been clear, we assume that all of the data can flow in the mesh network, this seems to make the problem much more interesting as there is a very large gap between the optimal solution and the worst feasible solution. This also implies that there are no Benders feasibility cuts.
	
	
	We set the upload cost to 1, the download cost to 0, the pigeon data capacity to 1e4, pigeon cost to 1e5 and the pigeon range to 5e3 meters. We run everything one time with a warm up phase on a small problem. The warm up phase is needed as Julia specializes (recompile the function for that specific type). We compare our method with gurobi and cplex(to come) on a i7-11700K with turbo and 32GB of ram with Linux.
	
		\begin{table}[h]\label{t:3}
		\sisetup{detect-all}
		%		\centering
		%\Rotatebox{90}
		\makebox[\linewidth]{
			\begin{tabular}{S[table-format=3] S[table-format=4] S[table-format=1.1] 
			S[table-format=1.1]
			S[table-format=1.1]
			S[table-format=1.1]}
				\toprule
				{$n$} & {$m$}   & 
				{col-Gurobi} & 
				{col-CPLEX} &
				{Gurobi} &
				{CPLEX} 				\\
				\midrule
6 & 10 & 0.0 & 0.0 & 0.0 & 0.0 \\
6 & 100 & 0.0 & 0.0 & 0.0 & 0.1 \\
6 & 500 & 0.0 & 0.0 & 0.3 & 0.3 \\
6 & 1000 & 0.1 & 0.1 & 0.9 & 1.1 \\
11 & 10 & 0.0 & 0.0 & 0.0 & 0.0 \\
11 & 100 & 0.0 & 0.0 & 0.2 & 0.2 \\
11 & 500 & 0.0 & 0.0 & 1.6 & 1.6 \\
11 & 1000 & 0.1 & 0.1 & 4.1 & 3.7 \\
				
				\bottomrule
			\end{tabular}
		}
		\caption{Time comparison between different multi-commodity solver (zero means less than one tenth of a second), time is in second in an $n$ by $n$ grid with $m$ commodity. }
	\end{table}
	\begin{table}[h]\label{t:4}
		\sisetup{detect-all}
		%		\centering
		%\Rotatebox{90}
		\makebox[\linewidth]{
			\begin{tabular}{
					S[table-format=3] 
					S[table-format=4]
					S[table-format=1.1]
					S[table-format=1.1]
					S[table-format=1.1]
					S[table-format=1.1]
					S[table-format=1.1]
				}
				\toprule
				{$n$} & {$m$}   & 
				{BGD} & 
				{BGG} &
				{BGC} &
				{Gurobi} & {CPLEX} 				\\
				\midrule
6 & 10 & 0.0 & 0.1 & 0.1 & 0.0 & 0.0 \\
 & 100 & 0.1 & 1.0 & 0.9 & 0.2 & 0.2 \\
 & 500 & 0.4 & 4.7 & 7.5 & 1.4 & 1.4 \\
 & 1000 & 0.2 & 23.3 & 34.4 & 28.8 & 28.4 \\				
				\bottomrule
			\end{tabular}
		}
		\caption{Time/duality gap comparison between different approaches. First 3 columns are Benders decomposition, the G denotes that they master problem was solved with Gurobi and the last letter shows what solver solved the sub-problem(C for CPLEX, D for Column Generation on the Dantzig-Wolfe decomposition). If the solver reached optimality, only the time was reported otherwise the time and the GAP was reported (with a time limit of 10 minutes). In all cases $s$ is 5 and $P$ is 1.}
	\end{table}
\printbibliography
\end{document}











%	For a specific $\bar{y} \in \mathbb{Z}^m$, the sub-problem either has a solution or is infeasible. The subproblem is always bounded by zero so it cannot be unbounded.
%	
%	If the sub-problem has a solution, we know that the function
%	\begin{equation}
	%		f(\bar{y}) = \min_x\{c\cdot x | Ax = b - B\bar{y}, x\geq 0\},\label{benders:3:sp}
	%	\end{equation}
%	is a convex function of $\bar{y}$. By the envelope theorem(cite), given the dual variables $u^*$ for $f(\bar{y})$, the gradient of $f(\bar{y})$ is given by the gradient of the Lagrangian
%	\begin{equation}
	%		L(x^*, u^*, \bar{y}) = c \cdot x^* + u^* \cdot (Ax^* - b + B\bar{y}).
	%	\end{equation}
%
%	The $\nabla_x^*L(x^*, u^*)$ is $c + A^\top u^*$, using the gradient we can write the first order approximation of $L$ at $\bar{y}^0$,
%	\begin{align}
	%	\bar{f}(\bar{y};\bar{y}^0) 
	%	&= L(x^*, u^*, \bar{y}^0) + \nabla_x^*L(x^*, u) \cdot (\bar{y} - \bar{y}^0) \\
	%	&= c \cdot x^* + u^* \cdot (Ax^* - b + B\bar{y}^0) + (c + A^\top u^*) \cdot (\bar{y} - \bar{y}^0) \\
	%	&= c \cdot x^* + u^* \cdot (Ax^* - b + B\bar{y}^0) + (c + A^\top u^*) \cdot (\bar{y} - \bar{y}^0).
	%	\end{align}
%	Since $x^*$ is feasible, $c \cdot x^*$ is equal to $(b - B\bar{y}^0) \cdot u^*$ thus 
%	\begin{align}
	%		&= (b - B\bar{y}^0) \cdot u^* + u^* \cdot (Ax^* - b + B\bar{y}^0) + (c + A^\top u^*) \cdot (\bar{y} - \bar{y}^0) \\
	%		&= u^* \cdot Ax^* + (c + A^\top u^*) \cdot (\bar{y} - \bar{y}^0) \\
	%		&= u^* \cdot Ax^* + (c + A^\top u^*) \cdot (\bar{y} - \bar{y}^0).
	%	\end{align}
%	We rewrite $Ax^*$ as $b - B \bar{y}^0$ to get:
%	\begin{align}
	%		&= u^* \cdot (b - B \bar{y}^0) + (c + A^\top u^*) \cdot (\bar{y} - \bar{y}^0) \\
	%		&= u^* \cdot (b - B \bar{y}^0) + (c + A^\top u^*) \cdot (\bar{y} - \bar{y}^0) \\
	%		&= u^* \cdot(b - A\bar{y})  +  c \cdot \bar{y} - ((B + A^\top) u^*)  \cdot \bar{y}^0 - c\cdot \bar{y}^0
	%	\end{align}
%	Since $f(y)$ is convex, any linear approximation is a lower bound for the function. 




%	\begin{equation}
	%	\max_u \{(b - By)^\top u | A^\top u \leq c\}
	%\end{equation}